package client.models;import client.controllers.Manager;import client.models.map.Cell;import client.models.map.Map;import client.models.match.Match;import client.views.Output;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.*;public class AI extends Account {    Match match;    private Queue<String> decisions = new LinkedList<>();    /// state[distanceToHero][oppHealth][myHealth][action]    int[][][][] state = new int[10][10][10][3];    private final int ACTIONS_NUMBER = 3;    int[] lastState = new int[3];    public AI(String username, String password) {        super(username, password);    }    private int distanceToOppHero() {        int distance = 0;        try {            distance = Cell.manhattanDistance(match.getPlayer1().getHero().getCell(),                    match.getPlayer2().getHero().getCell()) - 1;            if (distance >= 9)                distance = 9;        } catch (Exception ignored) {            Output.err("Ignored in AI");        }        return distance;    }    private int getHealth() {        int health = 0;        try {            health = match.getPlayer2().getHero().getCurrentHealth() / 5;            if (health >= 9)                health = 9;        } catch (Exception ignored) {            Output.err("Ignored in AI");        }        return health;    }    private int getOppHealth() {        int health = 0;        try {            health = match.getPlayer1().getHero().getCurrentHealth() / 5;            if (health >= 9)                health = 9;        } catch (Exception ignored) {            Output.err("Ignored in AI");        }        return health;    }    public void decide() {        reward();        int distance = lastState[0] = distanceToOppHero();        int myHealth = lastState[1] = getHealth();        int oppHealth = lastState[2] = getOppHealth();        int max = 0;        for (int i = 0; i < ACTIONS_NUMBER; i++) {            max = Math.max(max, state[distance][oppHealth][myHealth][i]);        }        if (max < 100) {            chooseAction(new Random().nextInt() % 3);            return;        }        for (int i = 0; i < ACTIONS_NUMBER; i++) {            if (state[distance][oppHealth][myHealth][i] == max) {                chooseAction(i);                return;            }        }//        if (t % 2 == 0)//            this.decision = "show hand";//        else//            this.decision = "end turn";//        t = (t + 1) % 2;    }    private void reward() {        getData();        int reward;        reward = ((lastState[2] - getOppHealth()) / 5) * 2;        state[lastState[0]][lastState[1]][lastState[2]][2] += reward;        reward = ((getHealth() - lastState[1]) / 5) * 3;        state[lastState[0]][lastState[1]][lastState[2]][2] += reward;        state[lastState[0]][lastState[1]][lastState[2]][0] += reward;        reward = (lastState[0] - distanceToOppHero()) * 4;        state[lastState[0]][lastState[1]][lastState[2]][1] += reward;        setData();    }    private void getData() {        FileReader fileReader;        try {            fileReader = new FileReader("Data.txt");        } catch (IOException e) {            e.printStackTrace();            return;        }        for (int i = 0; i < 10; i++)        for (int j = 0; j < 10; j++)        for (int k = 0; k < 10; k++)        for (int l = 0; l < 3; l++) {            try {                if ( (state[i][j][k][l] = fileReader.read()) == -1);            } catch (IOException e) {                e.printStackTrace();            }        }    }    private void setData() {        FileWriter fileWriter;        try {            fileWriter = new FileWriter("Data.txt");        } catch (IOException e) {            e.printStackTrace();            return;        }        for (int i = 0; i < 10; i++)        for (int j = 0; j < 10; j++)        for (int k = 0; k < 10; k++)        for (int l = 0; l < 3; l++) {            try {                fileWriter.write(state[i][j][k][l]);                fileWriter.write("\n");            } catch (IOException e) {                e.printStackTrace();            }        }    }    private void chooseAction(int action) {        switch (action) {            case 0:                insertCard();                break;            case 1:                moveCard();                break;            case 2:                attack();                break;            default:                decisions.add("end turn");        }    }    private void attack() {        selectCard();        try {            decisions.add("attack " + match.getPlayer1().getHero().getID());        } catch (Player.HeroDeadException e) {            Output.err("ignored in attack in AI");        }    }    private void insertCard() {        decisions.add("insert " + match.getPlayer2().getHand().getCards().get(Match.random(0, 4)).getID() + " in " +                Match.random(1, Map.ROW_NUMBER) + ", " + Match.random(1, Map.COLUMN_NUMBER));    }    private void selectCard() {        try {            decisions.add("select " + match.getPlayer2().getHero().getID());        } catch (Player.HeroDeadException e) {            Output.err("ignored in insertCard in AI");        }    }    private void moveCard() {        selectCard();        decisions.add("move to " + Match.random(1, Map.ROW_NUMBER) + ", " + Match.random(1, Map.COLUMN_NUMBER));    }    public String getDecision() {        if (match.getPlayer2().getMana() < 2)            return "end turn";        if (decisions.size() == 0)            decide();        return decisions.poll();    }    public void setMatch(Match playingMatch) {        this.match = playingMatch;    }    public static AI getAIAccount(Account opponent) {        AI aiAccount = new AI("AI", "password");        aiAccount.setMainDeck(new Deck(opponent.getMainDeck()));        return aiAccount;    }}